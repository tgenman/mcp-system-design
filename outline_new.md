# Структура презентации: "От REST к MCP: как LLM меняют принципы проектирования API и архитектуры систем"

## Новая структура

### 1. Контекст: эволюция API и появление LLM‑агентов (9-10 слайдов) ✅ ГОТОВО
- ✅ **Титульный слайд**: название + автор
- ✅ **Agenda**: что будем обсуждать
- ✅ **Что такое API?**: определение и контракт
- ✅ **Краткая история API**: от библиотек (≈1945) через закрепление термина (1968) до веб-API (≈2000)
- ✅ **Сравнительная таблица**: REST vs GraphQL vs gRPC (с детальным сравнением по 7 аспектам)
- ✅ **Общая проблема**: клиент должен заранее знать API (создает жесткую связанность)
- ✅ **Принцип HATEOAS**: почему он не решает проблему полностью (семантика, стандартизация, сложность)
- ✅ **2022-2025**: от ChatGPT (30 ноября 2022) до эпохи агентов (2025 - год агентов, 812M MAU)
- ✅ **Что такое Agent и отличие его от Workflow**: неопределенность вычислительного DAG как ключевое отличие
- ✅ **Постановка проблемы**: переход на использование LLM как consumer

### 2. Ограничения классических API в эпоху LLM (4-5 слайдов) ✅ ГОТОВО
- ✅ **Проблема MxN**: каждый AI должен интегрироваться с каждым сервисом (с иллюстрацией)
- ✅ **Проблема self-discovery**: агент не знает доступные API (vs запрограммированный клиент)
- ✅ **Проблема контекста**: stateless накладывает нагрузку на LLM и увеличивает ошибки
- ✅ **Проблема гранулярности**: мелкие операции vs человеческие задачи ("one tool, one human task")
- ✅ **Проблема выбора инструментов**: Cognitive Load и падение точности с ростом опций (с графиком)

### 3. Model Context Protocol: архитектура и решения (13-14 слайдов) ✅ ГОТОВО
- ✅ **Что такое MCP**: Model Context Protocol как открытый стандарт для подключения AI-ассистентов
- ✅ **Архитектура**: Client-Host-Server с иллюстрацией
- ✅ **Ключевые принципы дизайна MCP**:
  - Серверы должны быть крайне простыми в разработке
  - Серверы должны быть высоко композиционными
  - Серверы не должны видеть полный контекст диалога
  - Возможности могут добавляться прогрессивно
- ✅ **Capability Negotiation**: согласование возможностей между клиентами и серверами
- ✅ **Способы подключения**: локальное выполнение (STDIO) и удаленное (HTTP + SSE)
- ✅ **Решение проблемы MxN**: M + N вместо M × N (с иллюстрацией M+N.png)
- ✅ **Решение проблемы self-discovery**: динамическое обнаружение инструментов через runtime discovery
  - Программный способ узнать доступные операции через JSON-RPC методы tools/list
  - Примеры запросов и ответов с описанием инструментов
- ✅ **Решение проблемы контекста**: от stateless к stateful-сессиям  
  - Сравнение REST (каждый запрос содержит всю информацию) vs MCP (контекст сохраняется)
  - Примеры диалогов с сохранением состояния
- ✅ **Решение проблемы гранулярности**: "one tool, one human task"
  - Высокоуровневые инструменты вместо множества мелких вызовов
  - Пример: generate_customer_report вместо 5 отдельных REST вызовов
- ✅ **Решение проблемы выбора инструментов**: структурированная организация
  - Иерархическая организация по серверам для снижения Cognitive Load
  - Семантические описания для LLM и группировка по контексту
- ✅ **Дополнительные преимущества: гибкость развертывания**
  - Локальное выполнение (STDIO): высокая производительность, безопасность
  - Удаленное выполнение (HTTP + SSE): масштабируемость, централизованное управление  
- ✅ **Дополнительные преимущества: двунаправленная связь**
  - Server-initiated messages: progress notifications и sampling/createMessage
  - Примеры JSON-RPC сообщений для progress tracking и elicitation

### 4. Архитектурные сдвиги: от детерминизма к адаптивности (6-7 слайдов) ✅ ГОТОВО
- ✅ **Принцип 1: От детерминированности к адаптивности**:
  - Статические графы выполнения vs динамические графы выполнения
  - Визуализация через SVG диаграммы (statical_DAG.svg vs dynamic_DAG.svg)
  - Ключевой сдвиг: от программирования алгоритмов к программированию возможностей
- ✅ **Принцип 2: От императивного к декларативному**:
  - Изменение роли разработчика
  - Сравнение кода: JavaScript (императивный) vs JSON (декларативный)
  - Философия: вместо "как делать" определяем "что можно делать"
- ✅ **Принцип 3: От stateless к контекстным сессиям**:
  - Классический подход: каждый запрос независим (REST принцип)
  - MCP подход: память сессии, длительные операции, гибкое состояние
  - Компромисс: производительность диалога vs сложность масштабирования
- ✅ **Принцип 4: От однонаправленной к двунаправленной связи**:
  - Классические API: только request-response (с визуализацией request-responce.svg)
  - MCP: встроенная двунаправленность (с визуализацией bidirectional.svg)
  - Результат: более богатое взаимодействие, приближенное к человеческому диалогу
- ✅ **Принцип 5: Новая модель распределения ответственности**:
  - Таблица "Было vs Стало" с 4 ключевыми сдвигами
  - От детального контроля к определению политик
  - От статических контрактов к динамическим возможностям
- ✅ **Архитектурная метафора: от заводского конвейера к живому организму**:
  - Заводской конвейер: четкие операции, строгие функции (classical_workflow.svg)
  - Живой организм: адаптация, взаимодействие через "нервную систему" (life_graph.svg)
  - Требует нового мышления от архитекторов и разработчиков

### 5. Практика внедрения: паттерны, безопасность, примеры (11-12 слайдов)
- **AI Gateway как центральный компонент**:
  - Отдельный слой для приёма MCP-трафика (пример — Azure API Management)
  - Лимиты, валидация аргументов, мониторинг и аудит
  - Контроль политик и защита от prompt injection
- **Архитектурные паттерны**:
  - MCP-сервер как фасад для микросервисов
  - Оборачивание нескольких REST-вызовов в один высокоуровневый инструмент
  - Проблемы транзакционности в новой архитектуре
- **Наблюдаемость и надежность**:
  - Tracing агентных вызовов
  - Fallback-стратегии при сбоях LLM
  - Timeout-ы и circuit breakers для агентов
- **Пример реальной архитектуры**: корпоративная система с микросервисами
- **Специфические угрозы AI-эпохи**:
  - Prompt injection атаки
  - "Фальшивые" инструменты-двойники
  - Утечки данных через объединение инструментов
- **Изменения в модели безопасности**:
  - От доверия разработчику к контролю агента
  - Система разрешений на уровне инструментов
  - Моделирование поведения непредсказуемого клиента
- **Стратегии защиты**:
  - Изоляция локальных vs удаленных MCP-серверов
  - Аудит и логирование агентной активности
  - Политики доступа и ограничения
- **Практические bootstrap примеры**:
  - Код на Go: MCP server
  - Код на Python: MCP server

---