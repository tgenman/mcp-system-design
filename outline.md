# Структура презентации: "От REST к MCP: как LLM меняют принципы проектирования API и архитектуры систем"

### 1. Введение (3-4 слайда)
- **Титульный слайд**: название + автор
- **Agenda**: что будем обсуждать
- **Что такое API?**: определение и контракт
- **Краткая история API**: от библиотек (1945) до веб-API (2000)

### 2. Современное состояние API (4-5 слайдов)
- **Сравнительная таблица**: REST vs GraphQL vs gRPC
- **Общая проблема**: клиент должен заранее знать API
- **Принцип HATEOAS**: почему он не решает проблему полностью

### 3. Появление LLM-агентов (2-3 слайда)
- **2022-2025**: от GPT-3.5 до агентов в продакшене
- **Что такое Agent и отличие его от Workflow**
- **Какие же проблемы возникают при переходе на искользование LLM как consumer?**

### 4. Проблемы классических API в контексте LLM (4-5 слайдов)
- **Проблема MxN**: каждый AI должен интегрироваться с каждым сервисом
- **Проблема self-discovery**: агент не знает доступные API
- **Проблема контекста**: stateless не подходит для длительных сессий агентов
- **Проблема гранулярности**: мелкие операции vs человеческие задачи
- Проблема выбора инструментов среди слишком большого числа

### 5. Знакомство с MCP (4-5 слайдов)
- **Что такое MCP**: Model Context Protocol
- **Архитектура**: Client-Host-Server
- **Ключевые принципы**:
  - Self-discovery через tools/list
  - Stateful sessions
  - Единый JSON-RPC 2.0 протокол
  - Двунаправленная связь

### 6. Преимущества MCP (3-4 слайда)
- **Решение проблемы MxN**: M + N вместо M × N
- **Динамическое обнаружение**: runtime discovery инструментов
- **Контекстность**: сохранение состояния между вызовами
- **Крупнозернистые операции**: "one tool, one human task"
- **Локальное и удаленное выполнение**: STDIO и HTTP+SSE

### 7. Фундаментальные изменения в архитектуре (5-6 слайдов)
- **От детерминированности к адаптивности**:
  - Классика: заранее запрограммированные вызовы
  - MCP: динамическое принятие решений агентом
  - Новая роль разработчика: задать правила, а не точный сценарий
- **От stateless к stateful**:
  - Проблемы с load balancing
  - Sticky sessions и их реализация
  - Lifecycle management соединений
- **От однонаправленной к двунаправленной связи**:
  - Server-initiated messages как часть протокола
  - Progress notifications и elicitation
  - Сравнение с WebSockets vs встроенная возможность
- **Изменение роли оркестратора**:
  - Раньше: Frontend/BFF управляет последовательностью
  - Теперь: AI-агент принимает решения в runtime
  - Распределение логики между кодом и LLM

### 8. Практическая реализация новой архитектуры (5-6 слайдов)
- **AI Gateway как центральный компонент**:
  - Отдельный слой для приёма MCP-трафика (пример — Azure API Management)
  - Лимиты, валидация аргументов, мониторинг и аудит
  - Контроль политик и защита от prompt injection
- **Архитектурные паттерны**:
  - MCP-сервер как фасад для микросервисов
  - Оборачивание нескольких REST-вызовов в один высокоуровневый инструмент
  - Проблемы транзакционности в новой архитектуре
- **Наблюдаемость и надежность**:
  - Tracing агентных вызовов
  - Fallback-стратегии при сбоях LLM
  - Timeout-ы и circuit breakers для агентов
- **Пример реальной архитектуры**: корпоративная система с микросервисами

### 9. Вызовы и риски (4-5 слайдов)
- **Специфические угрозы AI-эпохи**:
  - Prompt injection атаки
  - "Фальшивые" инструменты-двойники
  - Утечки данных через объединение инструментов
- **Изменения в модели безопасности**:
  - От доверия разработчику к контролю агента
  - Система разрешений на уровне инструментов
  - Моделирование поведения непредсказуемого клиента
- **Стратегии защиты**:
  - Изоляция локальных vs удаленных MCP-серверов
  - Аудит и логирование агентной активности
  - Политики доступа и ограничения

### 10. Практические примеры (2-3 слайда)
- **Код на Go**: MCP server
- **Код на Python**: MCP server
