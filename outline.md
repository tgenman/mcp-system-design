# Структура презентации: "От REST к MCP: как LLM меняют принципы проектирования API и архитектуры систем"

### 1. Введение (3-4 слайда) ✅ ГОТОВО
- ✅ **Титульный слайд**: название + автор
- ✅ **Agenda**: что будем обсуждать
- ✅ **Что такое API?**: определение и контракт
- ✅ **Краткая история API**: от библиотек (≈1945) через закрепление термина (1968) до веб-API (≈2000)

### 2. Современное состояние API (4-5 слайдов) ✅ ГОТОВО
- ✅ **Сравнительная таблица**: REST vs GraphQL vs gRPC (с детальным сравнением по 7 аспектам)
- ✅ **Общая проблема**: клиент должен заранее знать API (создает жесткую связанность)
- ✅ **Принцип HATEOAS**: почему он не решает проблему полностью (семантика, стандартизация, сложность)

### 3. Появление LLM-агентов (2-3 слайда) ✅ ГОТОВО
- ✅ **2022-2025**: от ChatGPT (30 ноября 2022) до эпохи агентов (2025 - год агентов, 812M MAU)
- ✅ **Что такое Agent и отличие его от Workflow**: неопределенность вычислительного DAG как ключевое отличие
- ✅ **Постановка проблемы**: переход на использование LLM как consumer

### 4. Проблемы классических API в контексте LLM (4-5 слайдов) ✅ ГОТОВО
- ✅ **Проблема MxN**: каждый AI должен интегрироваться с каждым сервисом (с иллюстрацией)
- ✅ **Проблема self-discovery**: агент не знает доступные API (vs запрограммированный клиент)
- ✅ **Проблема контекста**: stateless накладывает нагрузку на LLM и увеличивает ошибки
- ✅ **Проблема гранулярности**: мелкие операции vs человеческие задачи ("one tool, one human task")
- ✅ **Проблема выбора инструментов**: Cognitive Load и падение точности с ростом опций (с графиком)

### 5. Знакомство с MCP (5-6 слайдов) ✅ ГОТОВО
- ✅ **Что такое MCP**: Model Context Protocol как открытый стандарт для подключения AI-ассистентов
- ✅ **Архитектура**: Client-Host-Server с иллюстрацией
- ✅ **Ключевые принципы дизайна MCP**:
  - Серверы должны быть крайне простыми в разработке
  - Серверы должны быть высоко композиционными
  - Серверы не должны видеть полный контекст диалога
  - Возможности могут добавляться прогрессивно
- ✅ **Capability Negotiation**: согласование возможностей между клиентами и серверами
- ✅ **Способы подключения**: локальное выполнение (STDIO) и удаленное (HTTP + SSE)

### 6. Как MCP решает проблемы классических API (7-8 слайдов) ✅ ГОТОВО
- ✅ **Решение проблемы MxN**: M + N вместо M × N (с иллюстрацией M+N.png)
- ✅ **Решение проблемы self-discovery**: динамическое обнаружение инструментов через runtime discovery
  - Программный способ узнать доступные операции через JSON-RPC методы tools/list
  - Примеры запросов и ответов с описанием инструментов
- ✅ **Решение проблемы контекста**: от stateless к stateful-сессиям  
  - Сравнение REST (каждый запрос содержит всю информацию) vs MCP (контекст сохраняется)
  - Примеры диалогов с сохранением состояния
- ✅ **Решение проблемы гранулярности**: "one tool, one human task"
  - Высокоуровневые инструменты вместо множества мелких вызовов
  - Пример: generate_customer_report вместо 5 отдельных REST вызовов
- ✅ **Решение проблемы выбора инструментов**: структурированная организация
  - Иерархическая организация по серверам для снижения Cognitive Load
  - Семантические описания для LLM и группировка по контексту
- ✅ **Дополнительные преимущества: гибкость развертывания**
  - Локальное выполнение (STDIO): высокая производительность, безопасность
  - Удаленное выполнение (HTTP + SSE): масштабируемость, централизованное управление  
- ✅ **Дополнительные преимущества: двунаправленная связь**
  - Server-initiated messages: progress notifications и sampling/createMessage
  - Примеры JSON-RPC сообщений для progress tracking и elicitation

### 7. Фундаментальные изменения в архитектуре (5-6 слайдов)
- **От детерминированности к адаптивности**:
  - Классика: заранее запрограммированные вызовы
  - MCP: динамическое принятие решений агентом
  - Новая роль разработчика: задать правила, а не точный сценарий
- **От stateless к stateful**:
  - Проблемы с load balancing
  - Sticky sessions и их реализация
  - Lifecycle management соединений
- **От однонаправленной к двунаправленной связи**:
  - Server-initiated messages как часть протокола
  - Progress notifications и elicitation
  - Сравнение с WebSockets vs встроенная возможность
- **Изменение роли оркестратора**:
  - Раньше: Frontend/BFF управляет последовательностью
  - Теперь: AI-агент принимает решения в runtime
  - Распределение логики между кодом и LLM

### 8. Практическая реализация новой архитектуры (5-6 слайдов)
- **AI Gateway как центральный компонент**:
  - Отдельный слой для приёма MCP-трафика (пример — Azure API Management)
  - Лимиты, валидация аргументов, мониторинг и аудит
  - Контроль политик и защита от prompt injection
- **Архитектурные паттерны**:
  - MCP-сервер как фасад для микросервисов
  - Оборачивание нескольких REST-вызовов в один высокоуровневый инструмент
  - Проблемы транзакционности в новой архитектуре
- **Наблюдаемость и надежность**:
  - Tracing агентных вызовов
  - Fallback-стратегии при сбоях LLM
  - Timeout-ы и circuit breakers для агентов
- **Пример реальной архитектуры**: корпоративная система с микросервисами

### 9. Вызовы и риски (4-5 слайдов)
- **Специфические угрозы AI-эпохи**:
  - Prompt injection атаки
  - "Фальшивые" инструменты-двойники
  - Утечки данных через объединение инструментов
- **Изменения в модели безопасности**:
  - От доверия разработчику к контролю агента
  - Система разрешений на уровне инструментов
  - Моделирование поведения непредсказуемого клиента
- **Стратегии защиты**:
  - Изоляция локальных vs удаленных MCP-серверов
  - Аудит и логирование агентной активности
  - Политики доступа и ограничения

### 10. Практические примеры (2-3 слайда)
- **Код на Go**: MCP server
- **Код на Python**: MCP server
